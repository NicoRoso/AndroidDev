# Отчет: Практика 4.
### Набиулин Глеб, БСБО-07-22

---
# Отчёт по разработке мобильных приложений

## 1. Music Player

Создан проект Lesson4 с использованием View Binding для связывания графических компонентов с кодом.

**Было реализовано**
- Включена функция View Binding путем добавления buildFeatures { viewBinding = true } в build.gradle

![screen1]()

- Создана разметка activity_main.xml для портретной и альбомной ориентации
- В MainActivity.java продемонстрировано использование сгенерированного класса ActivityMainBinding:
  - создание объекта класса через inflate;
  - установка корневого View через binding.getRoot() в setContentView;
  - доступ к отдельным компонентам разметки через поля binding объекта.
- Реализованы обработчики событий для кнопок

![screen2]()

![screen3]()

![screen4]()

---
## 2. Thread

Создан модуль **Thread**, демонстрирующий работу с главным и фоновыми потоками.  

**Основной функционал:**
1. В модуле активирована функция View Binding
2. - TextView для отображения информации о главном потоке.
    - EditText для ввода:

    - Общего количества пар.

    - Количества учебных дней.

    - Button для запуска вычислений.

    - TextView для вывода результата.
3. Логика в MainActivity.java
    - Работа с главным потоком:
      - Получение информации (Thread.currentThread()).
      - Переименование потока (группа, номер, любимый фильм).
      - Вывод стека вызовов и группы потока в Logcat.
    - Фоновый поток
      - Запуск по нажатию кнопки (new Thread(new Runnable() { ... }).start()).
      - Расчет среднего количества пар в день.
      - Имитация долгой операции (20 сек) через wait().
      - Безопасное обновление UI через runOnUiThread().


![screen5]()

![screen6]()

---
## 3. Data Thread

Модуль **data_thread** демонстрирует три ключевых способа обновления UI из фонового потока: **runOnUiThread()** для немедленного выполнения, **post()** для добавления в очередь UI и **postDelayed()** для отложенного выполнения. В разметке используется TextView для наглядного отображения последовательности операций и Button для запуска фонового потока. При нажатии кнопки создаётся фоновый поток, который с задержками вызывает все три метода, а результаты их работы с пояснениями выводятся в TextView ("1. runOnUiThread() - выполнен сразу...", "2. post() - добавлен в очередь..." и т.д.). Модуль наглядно показывает разницу между этими подходами и их приоритетность при планировании задач в UI-потоке, помогая понять базовые принципы многопоточности в Android.

![screen7]()

![screen8]()

---
## 4. Looper


Создан модуль, демонстрирующий межпоточное взаимодействие с использованием **Looper** и **Handler**.  

**Реализация:**  
1. **MyLooper** (фоновый поток)  
   - Создает свой **Looper** и **Handler**  
   - Обрабатывает сообщения с возрастом (задержка = N секунд) и профессией  
   - Возвращает результат в главный поток  

2. **MainActivity**  
   - Главный **Handler** для приема результатов  
   - Кнопка отправляет данные в **MyLooper** через его **Handler**


![screen9]()


---

## 5. Crypto Loader

Создан модуль CryptoLoader, демонстрирует асинхронную дешифровку данных с использованием **Loader** и **AES-шифрования**.  

1. **MainActivity**  
   - Реализует **LoaderCallbacks<String>** для обработки результатов  
   - Шифрует текст при нажатии кнопки
   - Запускает **MyLoader** через **LoaderManager.initLoader()** 

2. **MyLoader** (наследник **AsyncTaskLoader**)  
   - В фоне расшифровывает данные

3. **CryptoUtils**  
   - Генерация AES-ключа (**generateKey()**)  
   - Шифрование/дешифрование (**encryptMsg()**, **decryptMsg()**)  


**Особенности:**  
- Безопасная генерация ключа (SHA1PRNG)  
- Все криптооперации в фоне (AsyncTaskLoader)  
- Передача данных через Bundle (cipherText + key)

![screen10]()

---

## 6. Service App

  
Создан модуль ServiceApp, демонстрирующий работу с Foreground Service.

- Приложение содержит сервис PlayerService и активность MainActivity.
- В ресурсы добавлена музыкальная композиция (.mp3).
- PlayerService использует MediaPlayer для воспроизведения аудио в фоновом режиме.
- Сервис запускается как Foreground Service с постоянным уведомлением, содержащим название композиции, что позволяет музыке играть при свернутом приложении.
- В MainActivity добавлены кнопки "Воспроизвести" и "Остановить" для запуска (startForegroundService) и остановки (stopService) сервиса.
- В манифест добавлены необходимые разрешения.


![screen11]()

![screen12]()

---

## 7. Work Manager

Был создан модуль, который демонстрирует работу с фоновыми задачами через **Android WorkManager API**.

**Основные компоненты:**

1. **UploadWorker** (наследник Worker)
   - Выполняет 10-секундную фоновую операцию
   - Принимает входные данные через `getInputData()`
   - Возвращает результат через `Result.success(outputData)`
   - Логирует ключевые этапы выполнения

2. **MainActivity**:
   - Создает Constraints
   - Формирует входные данные
   - Создает WorkRequest
   - Запускает задачу и отслеживает статус через LiveData

3. **Разметка (activity_main.xml)**:
   - TextView для отображения статуса
   - Button для запуска задачи

Также:
- Задача выполняется только при наличии интернет-соединения
- Поддержка передачи данных между компонентами (input/output)
- Автоматическое управление жизненным циклом задачи
- Наблюдение за состоянием через LiveData
- Логирование всех этапов выполнения

![screen13]()

![screen14]()

![screen15]()

---

## 8. Mirea Project

В проекте MireaProject добавлена система выполнения фоновых операций с использованием WorkManager.


1. **MyWorker**  
   - Класс-исполнитель фоновой задачи (наследник **Worker**)  
   - Эмулирует 5-секундную операцию (загрузку данных)  
   - Возвращает **Result.success()** при успешном выполнении  
   - Логирует ключевые этапы работы  

2. **WorkFragment**  
   - UI для управления задачами:  
     - Кнопка запуска (**buttonStartWork**)  
     - Поля для отображения статуса (**textStatus**) и результата (**textResult**)  
   - Настройка ограничений
   - Запуск задачи через **WorkManager.enqueue()**  
   - Отслеживание статуса в реальном времени через **LiveData**  

**Логика работы:**  
1. Пользователь нажимает кнопку → создается **OneTimeWorkRequest** с ограничениями.  
2. WorkManager запускает **MyWorker** при соблюдении условий (наличие сети).  
3. Во время выполнения:  
   - В UI отображается текущий статус (**ENQUEUED**, **RUNNING**).  
4. После завершения:  
   - Обновляется статус (**SUCCEEDED**).  
   - Выводится результат: *"Данные отправлены"*.  

**Особенности:**  
- **Гибкие условия**: Задачи выполняются только при подключении к интернету.  
- **Наблюдаемость**: Статус обновляется в реальном времени через **LiveData**.  
- **Отказоустойчивость**: При ошибке возвращается **Result.failure()**.  

Интеграция WorkManager обеспечивает стабильную работу фоновых процессов с учетом системных ограничений Android.

![screen11]()

![screen12]()

![screen13]()
